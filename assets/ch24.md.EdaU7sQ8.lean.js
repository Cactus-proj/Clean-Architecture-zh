import{_ as r,I as l,o as d,c as p,ak as n,J as i,w as s,a,j as t,aA as c}from"./chunks/framework.Jd6FJBrZ.js";const w=JSON.parse('{"title":"Chap24. PARTIAL BOUNDARIES 不完全边界","description":"","frontmatter":{},"headers":[],"relativePath":"ch24.md","filePath":"ch24.md","lastUpdated":1770724262000}'),h={name:"ch24.md"};function u(b,e,m,f,y,g){const o=l("Figures");return d(),p("div",null,[e[2]||(e[2]=n("",22)),i(o,{figure:"24-1"},{default:s(()=>[...e[0]||(e[0]=[a("The Strategy pattern",-1)])]),_:1}),e[3]||(e[3]=t("p",null,"It should be clear that this sets the stage for a future architectural boundary. The necessary dependency inversion is in place in an attempt to isolate the Client from the ServiceImpl. It should also be clear that the separation can degrade pretty rapidly, as shown by the nasty dotted arrow in the diagram. Without reciprocal interfaces, nothing prevents this kind of backchannel other than the diligence and discipline of the developers and architects.",-1)),e[4]||(e[4]=t("blockquote",null,[t("p",null,"很明显，上述设计为未来构建完整的系统架构边界打下了坚实基础。为了未来将 Client 与 ServiceImpl 隔离，必要的依赖反转已经做完了。同时，我们也能清楚地看到，图中的虚线箭头代表了未来有可能很快就会出问题的隔离问题。由于没有采用双向反向接口，这部分就只能依赖开发者和架构师的自律性来保证组件持久隔离了。")],-1)),e[5]||(e[5]=t("h2",{id:"facades-门户模式",tabindex:"-1"},[a("FACADES 门户模式 "),t("a",{class:"header-anchor",href:"#facades-门户模式","aria-label":"Permalink to “FACADES 门户模式”"},"​")],-1)),e[6]||(e[6]=t("p",null,"An even simpler boundary is the Facade pattern, illustrated in Figure 24.2. In this case, even the dependency inversion is sacrificed. The boundary is simply defined by the Facade class, which lists all the services as methods, and deploys the service calls to classes that the client is not supposed to access.",-1)),e[7]||(e[7]=t("blockquote",null,[t("p",null,"下面，我们再来看一个更简单的架构边界设计：采用门户模式（facade pattern），其架构如图 24.2 所示。在这种模式下，我们连依赖反转的工作都可以省了。这里的边界将只能由 Facade 类来定义，这个类的背后是一份包含了所有服务函数的列表，它会负责将 Client 的调用传递给对 client 不可见的服务函数。")],-1)),i(o,{figure:"24-2"},{default:s(()=>[...e[1]||(e[1]=[a("The Facade pattern",-1)])]),_:1}),e[8]||(e[8]=n("",9))])}const v=r(h,[["render",u]]);export{w as __pageData,v as default};
