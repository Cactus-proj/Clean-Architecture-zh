import{_ as l,I as r,o as h,c as u,ak as i,J as n,w as s,a,j as t,aB as p}from"./chunks/framework.Jd6FJBrZ.js";const T=JSON.parse('{"title":"Chap25. LAYERS AND BOUNDARIES 层次与边界","description":"","frontmatter":{},"headers":[],"relativePath":"ch25.md","filePath":"ch25.md","lastUpdated":1770724262000}'),d={name:"ch25.md"};function m(c,e,g,b,y,f){const o=r("Figures");return h(),u("div",null,[e[7]||(e[7]=i("",13)),n(o,{figure:"25-1"},{default:s(()=>[...e[0]||(e[0]=[a("Any number of UI components can reuse the game rules",-1)])]),_:1}),e[8]||(e[8]=t("p",null,"Let’s also assume that the state of the game is maintained on some persistent store—perhaps in flash, or perhaps in the cloud, or maybe just in RAM. In any of those cases, we don’t want the game rules to know the details. So, again, we’ll create an API that the game rules can use to communicate with the data storage component.",-1)),e[9]||(e[9]=t("blockquote",null,[t("p",null,"同时，假设玩家在游戏中的状态会被保存在某种持久化存储介质中——有可能闪存，也有可能是某种云端存储，或只是本机内存。无论怎样，我们都并不希望游戏引擎了解这些细节。所以，我们仍然需要创建一个 API 来负责游戏的业务逻辑组件与数据存储组件之间的通信。")],-1)),e[10]||(e[10]=t("p",null,"We don’t want the game rules to know anything about the different kinds of data storage, so the dependencies have to be properly directed following the Dependency Rule, as shown in Figure 25.2.",-1)),e[11]||(e[11]=t("blockquote",null,[t("p",null,"由于我们不会希望让游戏的业务逻辑依赖于不同种类的数据存储，所以这里的设计也要合理地遵守依赖关系原则，这样的话，该游戏的结构应如图 25.2 所示。")],-1)),n(o,{figure:"25-2"},{default:s(()=>[...e[1]||(e[1]=[a("Following the Dependency Rule",-1)])]),_:1}),e[12]||(e[12]=t("h2",{id:"clean-architecture-可否采用整洁架构",tabindex:"-1"},[a("CLEAN ARCHITECTURE? 可否采用整洁架构 "),t("a",{class:"header-anchor",href:"#clean-architecture-可否采用整洁架构","aria-label":"Permalink to “CLEAN ARCHITECTURE? 可否采用整洁架构”"},"​")],-1)),e[13]||(e[13]=t("p",null,"It should be clear that we could easily apply the clean architecture approach in this context,1 with all the use cases, boundaries, entities, and corresponding data structures. But have we really found all the significant architectural boundaries?",-1)),e[14]||(e[14]=t("blockquote",null,[t("p",null,"很显然，这里具备了采用整洁架构方法所需要的—切，包括用例、业务实体以及对应的数据结构都有了，但我们是否已经找到了所有相应的架构边界呢？")],-1)),e[15]||(e[15]=t("p",null,"For example, language is not the only axis of change for the UI. We also might want to vary the mechanism by which we communicate the text. For example, we might want to use a normal shell window, or text messages, or a chat application. There are many different possibilities.",-1)),e[16]||(e[16]=t("blockquote",null,[t("p",null,"例如，语言并不是 UI 变更的唯一方向。我们可能还会需要变更文字输入/输出的方式。例如我们的输入/输出可以采用命令行窗口，或者用短信息，或者采用某种聊天程序。这里的可能性有很多。")],-1)),e[17]||(e[17]=t("p",null,"That means that there is a potential architectural boundary defined by this axis of change. Perhaps we should construct an API that crosses that boundary and isolates the language from the communications mechanism; that idea is illustrated in Figure 25.3.",-1)),e[18]||(e[18]=t("blockquote",null,[t("p",null,"这就意味着这类变更应该有一个对应的架构边界。也许我们需要构造一个 API，以便将语言部分与通信部分隔开，这样一来，该设计的结构应如图 25.3 所示。")],-1)),n(o,{figure:"25-3"},{default:s(()=>[...e[2]||(e[2]=[a("The revised diagram",-1)])]),_:1}),e[19]||(e[19]=i("",14)),n(o,{figure:"25-4"},{default:s(()=>[...e[3]||(e[3]=[a("Simplified diagram",-1)])]),_:1}),e[20]||(e[20]=i("",11)),n(o,{figure:"25-5"},{default:s(()=>[...e[4]||(e[4]=[a("Adding a network component",-1)])]),_:1}),e[21]||(e[21]=i("",9)),n(o,{figure:"25-6"},{default:s(()=>[...e[5]||(e[5]=[a("The higher-level policy manages the player",-1)])]),_:1}),e[22]||(e[22]=t("p",null,"Is this an architectural boundary? Do we need an API that separates MoveManagement from PlayerManagement? Well, let’s make this a bit more interesting and add micro-services.",-1)),e[23]||(e[23]=t("blockquote",null,[t("p",null,"这些究竟是否属于架构边界呢？是否需要设计一个 API 来分割 MoveManagement 和 PlayerManagement 呢？在回答这些问题之前，让我们把问题弄得更有意思一点，再往里面加上微服务吧！")],-1)),e[24]||(e[24]=t("p",null,"Let’s assume that we’ve got a massive multiplayer version of Hunt the Wumpus. MoveManagement is handled locally within the player’s computer, but PlayerManagement is handled by a server. PlayerManagement offers a micro-service API to all the connected MoveManagement components.",-1)),e[25]||(e[25]=t("blockquote",null,[t("p",null,"假设我们现在面对的是一个可以面向海量玩家的新版 Hurit The Wumpus 游戏。它的 MoveManagmenet 组合是由玩家的本地计算机来处理的 。而 PlayerManagement 组件则由服务端来处理。但 PlayerManagement 组件会为所有连接上它的 MoveManagement 组件提供一个微服务的 API。")],-1)),e[26]||(e[26]=t("p",null,"The diagram in Figure 25.7 depicts this scenario in a somewhat abbreviated fashion. The Network elements are a bit more complex than depicted—but you can probably still get the idea. A full-fledged architectural boundary exists between MoveManagement and PlayerManagement in this case.",-1)),e[27]||(e[27]=t("blockquote",null,[t("p",null,"在图 25.7 中，我们为该游戏绘制了一个简化版的设计图。现实中的 Network 组件通常会比图中的更复杂一些 但这里的已经足够说明情况了。在图中，可以看到 MoveMangament PlayerManagment 之间存在一个完整的系统架构边界。")],-1)),n(o,{figure:"25-7"},{default:s(()=>[...e[6]||(e[6]=[a("Adding a micro-service API",-1)])]),_:1}),e[28]||(e[28]=i("",15))])}const k=l(d,[["render",m]]);export{T as __pageData,k as default};
