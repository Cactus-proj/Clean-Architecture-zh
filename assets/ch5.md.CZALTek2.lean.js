import{_ as l,I as p,o as k,c as o,ak as e,J as t,w as n,a as h,j as i,aN as r}from"./chunks/framework.Jd6FJBrZ.js";const b=JSON.parse('{"title":"Chap5. OBJECT-ORIENTED PROGRAMMING 面向对象编程","description":"","frontmatter":{},"headers":[],"relativePath":"ch5.md","filePath":"ch5.md","lastUpdated":1770724262000}'),d={name:"ch5.md"};function c(E,s,g,y,u,F){const a=p("Figures");return k(),o("div",null,[s[3]||(s[3]=e("",119)),t(a,{figure:"5-1"},{default:n(()=>[...s[0]||(s[0]=[h("Source code dependencies versus flow of control",-1)])]),_:1}),s[4]||(s[4]=i("p",null,"For mainq1w2e3r4 to call one of the high-level functions, it had to mention the name of the module that contained that function In C, this was a #include. In Java, it was an import statement. In C#, it was a using statement. Indeed, every caller was forced to mention the name of the module that contained the callee.",-1)),s[5]||(s[5]=i("blockquote",null,[i("p",null,"如你所见，main 函数为了调用高层函数，它就必须能够看到这个函数所在模块。在 C 中，我们会通过 #include 来实现，在 Java 中则通过 import 来实现，而在 C# 中则用的是 using 语句。总之，每个函数的调用方都必须要引用被调用方所在的模块。")],-1)),s[6]||(s[6]=i("p",null,"This requirement presented the software architect with few, if any, options. The flow of control was dictated by the behavior of the system, and the source code dependencies were dictated by that flow of control.",-1)),s[7]||(s[7]=i("blockquote",null,[i("p",null,"显然，这样做就导致了我们在软件架构上别无选择。在这里，系统行为决定了控制流，而控制流则决定了源代码依赖关系。")],-1)),s[8]||(s[8]=i("p",null,"When polymorphism is brought into play, however, something very different can happen (Figure 5.2).",-1)),s[9]||(s[9]=i("blockquote",null,[i("p",null,"但一旦我们使用了多态，情况就不一样了（详见图 5.2）。")],-1)),t(a,{figure:"5-2"},{default:n(()=>[...s[1]||(s[1]=[h("Dependency inversion",-1)])]),_:1}),s[10]||(s[10]=e("",14)),t(a,{figure:"5-3"},{default:n(()=>[...s[2]||(s[2]=[h("The database and the user interface depend on the business rules",-1)])]),_:1}),s[11]||(s[11]=e("",13))])}const f=l(d,[["render",c]]);export{b as __pageData,f as default};
