import{_ as h,I as o,o as r,c as p,ak as l,J as t,w as n,a as i,j as s,aF as d}from"./chunks/framework.Jd6FJBrZ.js";const b=JSON.parse('{"title":"Chap29. CLEAN EMBEDDED ARCHITECTURE 整洁的嵌入式架构","description":"","frontmatter":{},"headers":[],"relativePath":"ch29.md","filePath":"ch29.md","lastUpdated":1770724692000}'),k={name:"ch29.md"};function c(g,e,u,y,E,f){const a=o("Figures");return r(),p("div",null,[e[6]||(e[6]=l("",84)),t(a,{figure:"29-1"},{default:n(()=>[...e[0]||(e[0]=[i("Three layers",-1)])]),_:1}),e[7]||(e[7]=s("p",null,"The separation between hardware and the rest of the system is a given—at least once the hardware is defined (Figure 29.2). Here is where the problems often begin when you are trying to pass the App-titude test. There is nothing that keeps hardware knowledge from polluting all the code. If you are not careful about where you put things and what one module is allowed to know about another module, the code will be very hard to change. I’m not just talking about when the hardware changes, but when the user asks for a change, or when a bug needs to be fixed.",-1)),e[8]||(e[8]=s("blockquote",null,[s("p",null,"硬件与系统其他部分的分隔是既定的——至少在硬件设计完成之后如此（如图 29.2 所示）。这也是在我们试图通过程序适用测试之时往往会发生问题的地方。因为没有什么东西可以真正阻碍硬件实现细节污染到应用代码。如果我们在构建代码的时候不够小心，没有小心安排哪些模块之间可以互相依赖，代码很快就非常难以更改了。请注意，这里所说的变更不仅仅是指来自硬件的变更，还包括用户的功能性变更、修复代码中的 Bug。")],-1)),t(a,{figure:"29-2"},{default:n(()=>[...e[1]||(e[1]=[i("Hardware must be separated from the rest of the system",-1)])]),_:1}),e[9]||(e[9]=s("p",null,"Software and firmware intermingling is an anti-pattern. Code exhibiting this anti-pattern will resist changes. In addition, changes will be dangerous, often leading to unintended consequences. Full regression tests of the whole system will be needed for minor changes. If you have not created externally instrumented tests, expect to get bored with manual tests—and then you can expect new bug reports.",-1)),e[10]||(e[10]=s("blockquote",null,[s("p",null,"另外，软件与固件集成在一起也属于设计上的反模式（anti-pattern）。符合这种反模式的代码修改起来都会很困难。同时，这种代码也很危险，容易造成意外事故，这导致它经历任何微少的改动都需要进行完整的回归测试。如果没有完善的测试流程，那么你就等着无穷无尽的手工测试吧——同时还有纷沓而来的 Bug 报告。")],-1)),e[11]||(e[11]=s("h3",{id:"the-hardware-is-a-detail-硬件是实现细节",tabindex:"-1"},[i("The Hardware Is a Detail 硬件是实现细节 "),s("a",{class:"header-anchor",href:"#the-hardware-is-a-detail-硬件是实现细节","aria-label":"Permalink to “The Hardware Is a Detail 硬件是实现细节”"},"​")],-1)),e[12]||(e[12]=s("p",null,"The line between software and firmware is typically not so well defined as the line between code and hardware, as shown in Figure 29.3.",-1)),e[13]||(e[13]=s("blockquote",null,[s("p",null,"软件与固件之间的边界往往没有代码与硬件之间的边界那么清晰，如图 29.3 所示。")],-1)),t(a,{figure:"29-3"},{default:n(()=>[...e[2]||(e[2]=[i("The line between software and firmware is a bit fuzzier than the line between code and hardware",-1)])]),_:1}),e[14]||(e[14]=s("p",null,"One of your jobs as an embedded software developer is to firm up that line. The name of the boundary between the software and the firmware is the hardware abstraction layer (HAL) (Figure 29.4). This is not a new idea: It has been in PCs since the days before Windows.",-1)),e[15]||(e[15]=s("blockquote",null,[s("p",null,"所以，我们的工作之一就是将这个边界定义得更清晰一些。软件与固件之间的边界被称为硬件抽象层（HAL），如图 29.4 所示。这不是一个新概念，它在 PC 上的存在甚至可以追溯到 Windows 诞生之前。")],-1)),t(a,{figure:"29-4"},{default:n(()=>[...e[3]||(e[3]=[i("The hardware abstraction layer",-1)])]),_:1}),e[16]||(e[16]=l("",45)),t(a,{figure:"29-5"},{default:n(()=>[...e[4]||(e[4]=[i("Adding in an operating system",-1)])]),_:1}),e[17]||(e[17]=s("p",null,"A clean embedded architecture isolates software from the operating system, through an operating system abstraction layer (OSAL) (Figure 29.6). In some cases, implementing this layer might be as simple as changing the name of a function. In other cases, it might involve wrapping several functions together.",-1)),e[18]||(e[18]=s("blockquote",null,[s("p",null,"整洁的嵌入式架构会引入操作系统抽象层（OSAL，如图 29.6 所示），将软件与操作系统分割开。在某些情况下，实现这个抽象层就像给函数改个名字那么简单。而在另一些情况下，则需要将几个函数封装在一起。")],-1)),t(a,{figure:"29-6"},{default:n(()=>[...e[5]||(e[5]=[i("The operating system abstraction layer",-1)])]),_:1}),e[19]||(e[19]=l("",29))])}const w=h(k,[["render",c]]);export{b as __pageData,w as default};
