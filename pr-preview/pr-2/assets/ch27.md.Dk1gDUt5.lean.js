import{_ as r,I as l,c,o as h,aj as n,J as s,j as t,w as i,a as o,aC as d}from"./chunks/framework.BLu8HwH_.js";const w=JSON.parse('{"title":"Chap27. SERVICES: GREAT AND SMALL 服务：宏观与微观","description":"","frontmatter":{},"headers":[],"relativePath":"ch27.md","filePath":"ch27.md","lastUpdated":1767288275000}'),p={name:"ch27.md"};function u(b,e,m,f,v,y){const a=l("Figures");return h(),c("div",null,[e[4]||(e[4]=n("",42)),s(a,{figure:"27-1"},{default:i(()=>[...e[0]||(e[0]=[o("Services arranged to implement the taxi aggregator system",-1)])]),_:1}),e[5]||(e[5]=n("",29)),s(a,{figure:"27-2"},{default:i(()=>[...e[1]||(e[1]=[o("Using an object-oriented approach to deal with cross-cutting concerns",-1)])]),_:1}),e[6]||(e[6]=t("h2",{id:"component-based-services-基于组件的服务",tabindex:"-1"},[o("COMPONENT-BASED SERVICES 基于组件的服务 "),t("a",{class:"header-anchor",href:"#component-based-services-基于组件的服务","aria-label":"Permalink to “COMPONENT-BASED SERVICES 基于组件的服务”"},"​")],-1)),e[7]||(e[7]=t("p",null,"The obvious question is: Can we do that for services? And the answer is, of course: Yes! Services do not need to be little monoliths. Services can, instead, be designed using the SOLID principles, and given a component structure so that new components can be added to them without changing the existing components within the service.",-1)),e[8]||(e[8]=t("blockquote",null,[t("p",null,"那么，问题来了：服务化也可以做到这一点吗？答案是肯定的。服务并不一定必须是小型的单体程序。服务也可以按照 SOLID 原则来设计，按照组件结构来部署，这样就可以做到在添加/删除组件时不影响服务中的其他组件。")],-1)),e[9]||(e[9]=t("p",null,"Think of a service in Java as a set of abstract classes in one or more jar files. Think of each new feature or feature extension as another jar file that contains classes that extend the abstract classes in the first jar files. Deploying a new feature then becomes not a matter of redeploying the services, but rather a matter of simply adding the new jar files to the load paths of those services. In other words, adding new features conforms to the Open-Closed Principle.",-1)),e[10]||(e[10]=t("blockquote",null,[t("p",null,"我们可以将 Java 中的服务看作是一个或多个 jar 文件中的一组抽象类，而每个新功能或功能扩展都是另一个 jar 文件中的类，它们都扩展了之前 jar 文件中的抽象类。这样一来，部署新功能就不再是部署服务了，而只是简单地在服务的加载路径下增加一个 jar 文件。换句话说，这种增加新功能的过程符合开闭原则（OCP）。")],-1)),e[11]||(e[11]=t("p",null,"The service diagram in Figure 27.3 shows the structure. The services still exist as before, but each has its own internal component design, allowing new features to be added as new derivative classes. Those derivative classes live within their own components.",-1)),e[12]||(e[12]=t("blockquote",null,[t("p",null,"这种服务的架构如图 27.3 所示。我们可以看到，在该架构中服务仍然和之前一样，但是每个服务中都增加了内部组件结构，以便使用衍生类来添加新功能，而这些衍生类都有各自所生存的组件。")],-1)),s(a,{figure:"27-3"},{default:i(()=>[...e[2]||(e[2]=[o("Each service has its own internal component design, enabling new features to be added as new derivative classes",-1)])]),_:1}),e[13]||(e[13]=t("h2",{id:"cross-cutting-concerns-横跨型变更",tabindex:"-1"},[o("CROSS-CUTTING CONCERNS 横跨型变更 "),t("a",{class:"header-anchor",href:"#cross-cutting-concerns-横跨型变更","aria-label":"Permalink to “CROSS-CUTTING CONCERNS 横跨型变更”"},"​")],-1)),e[14]||(e[14]=t("p",null,"What we have learned is that architectural boundaries do not fall between services. Rather, those boundaries run through the services, dividing them into components.",-1)),e[15]||(e[15]=t("blockquote",null,[t("p",null,"现在我们应该已经明白了，系统的架构边界事实上并不落在服务之间，而是穿透所有服务，在服务内部以组件的形式存在。")],-1)),e[16]||(e[16]=t("p",null,"To deal with the cross-cutting concerns that all significant systems face, services must be designed with internal component architectures that follow the Dependency Rule, as shown in the diagram in Figure 27.4. Those services do not define the architectural boundaries of the system; instead, the components within the services do.",-1)),e[17]||(e[17]=t("blockquote",null,[t("p",null,"为了处理这个所有大型系统都会遇到的横跨型变更问题，我们必须在服务内部采用遵守依赖关系原则的组件设计方式，如图 27.4 所示。总而言之，服务边界并不能代表系统的架构边界，服务内部的组件边界才是。")],-1)),s(a,{figure:"27-4"},{default:i(()=>[...e[3]||(e[3]=[o("Services must be designed with internal component architectures that follow the Dependency Rule",-1)])]),_:1}),e[18]||(e[18]=t("h2",{id:"conclusion-本章小结",tabindex:"-1"},[o("CONCLUSION 本章小结 "),t("a",{class:"header-anchor",href:"#conclusion-本章小结","aria-label":"Permalink to “CONCLUSION 本章小结”"},"​")],-1)),e[19]||(e[19]=t("p",null,"As useful as services are to the scalability and develop-ability of a system, they are not, in and of themselves, architecturally significant elements. The architecture of a system is defined by the boundaries drawn within that system, and by the dependencies that cross those boundaries. That architecture is not defined by the physical mechanisms by which elements communicate and execute.",-1)),e[20]||(e[20]=t("blockquote",null,[t("p",null,"虽然服务化可能有助于提升系统的可扩展性和可研发性，但服务本身却并不能代表整个系统的架构设计。系统的架构是由系统内部的架构边界，以及边界之间的依赖关系所定义的，与系统中各组件之间的调用和通信方式无关。")],-1)),e[21]||(e[21]=t("p",null,"A service might be a single component, completely surrounded by an architectural boundary. Alternatively, a service might be composed of several components separated by architectural boundaries. In rare2 cases, clients and services may be so coupled as to have no architectural significance whatever.",-1)),e[22]||(e[22]=t("blockquote",null,[t("p",null,"一个服务可能是一个独立组件，以系统架构边界的形式隔开。一个服务也可能由几个组件组成，其中的组件以架构边界的形式互相隔离。在极端情况下，客户端和服务端甚至可能会由于耦合得过于紧密而不具备系统架构意义上的隔离性。")],-1))])}const k=r(p,[["render",u]]);export{w as __pageData,k as default};
