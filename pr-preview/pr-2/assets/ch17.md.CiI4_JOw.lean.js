import{_ as r,I as h,c as l,o as d,aj as i,J as s,j as t,w as n,a,as as u}from"./chunks/framework.BLu8HwH_.js";const k=JSON.parse('{"title":"Chap17. BOUNDARIES: DRAWING LINES 划分边界","description":"","frontmatter":{},"headers":[],"relativePath":"ch17.md","filePath":"ch17.md","lastUpdated":1767288275000}'),c={name:"ch17.md"};function p(b,e,m,f,w,g){const o=h("Figures");return d(),l("div",null,[e[6]||(e[6]=i("",83)),s(o,{figure:"17-1"},{default:n(()=>[...e[0]||(e[0]=[a("The database behind an interface",-1)])]),_:1}),e[7]||(e[7]=t("p",null,"The classes and interfaces in this diagram are symbolic. In a real application, there would be many business rule classes, many database interface classes, and many database access implementations. All of them, though, would follow roughly the same pattern.",-1)),e[8]||(e[8]=t("blockquote",null,[t("p",null,"这里的类与接口仅仅是一个例子。在一个真实的应用程序中，将会有很多业务逻辑类、很多数据库接口类以及很多数据库访问的实现。不过，所有一切所遵循的模式应该是相似的。")],-1)),e[9]||(e[9]=t("p",null,"Where is the boundary line? The boundary is drawn across the inheritance relationship, just below the DatabaseInterface (Figure 17.2).",-1)),e[10]||(e[10]=t("blockquote",null,[t("p",null,"那么这里的边界线应该被画在哪里？边界应该穿过继承关系，在 DatabaseInterface 之下（见图 17.2）。")],-1)),s(o,{figure:"17-2"},{default:n(()=>[...e[1]||(e[1]=[a("The boundary line",-1)])]),_:1}),e[11]||(e[11]=t("p",null,"Note the two arrows leaving the DatabaseAccess class. Those two arrows point away from the DatabaseAccess class. That means that none of these classes knows that the DatabaseAccess class exists.",-1)),e[12]||(e[12]=t("blockquote",null,[t("p",null,"请注意，DatabaseAccess 类的那两个对外的箭头。这两个箭头都指向了远离 DatabaseAccess 类的方向，这意味着它们所指向的两个类都不知道 DatabaseAccess 类的存在。")],-1)),e[13]||(e[13]=t("p",null,"Now let’s pull back a bit. We’ll look at the component that contains many business rules, and the component that contains the database and all its access classes (Figure 17.3).",-1)),e[14]||(e[14]=t("blockquote",null,[t("p",null,"下面让我们把抽象层次拉高一点，看一下包含多个业务逻辑类的组件与包含数据库及其访问类的组件之间是什么关系（见图 17.3）。")],-1)),s(o,{figure:"17-3"},{default:n(()=>[...e[2]||(e[2]=[a("The business rules and database components",-1)])]),_:1}),e[15]||(e[15]=i("",17)),s(o,{figure:"17-4"},{default:n(()=>[...e[3]||(e[3]=[a("The boundary between GUI and BusinessRules components",-1)])]),_:1}),e[16]||(e[16]=t("p",null,"Having drawn this boundary and this arrow, we can now see that the GUI could be replaced with any other kind of interface—and the BusinessRules would not care.",-1)),e[17]||(e[17]=t("blockquote",null,[t("p",null,"通过这条边界线以及这个箭头，我们可以看出 GUI 可以用任何一种其他形式的界面来代替。BusinessRules 组件不需要了解这些细节。")],-1)),e[18]||(e[18]=t("h2",{id:"plugin-architecture-插件式架构",tabindex:"-1"},[a("PLUGIN ARCHITECTURE 插件式架构 "),t("a",{class:"header-anchor",href:"#plugin-architecture-插件式架构","aria-label":"Permalink to “PLUGIN ARCHITECTURE 插件式架构”"},"​")],-1)),e[19]||(e[19]=t("p",null,"Taken together, these two decisions about the database and the GUI create a kind of pattern for the addition of other components. That pattern is the same pattern that is used by systems that allow third-party plugins.",-1)),e[20]||(e[20]=t("blockquote",null,[t("p",null,"综上所述，我们似乎可以基于数据库和 GUI 这两个为例来建立一种向系统添加其他组件的模式。这种模式与支持第三方插件的系统模式是一样的。")],-1)),e[21]||(e[21]=t("p",null,"Indeed, the history of software development technology is the story of how to conveniently create plugins to establish a scalable and maintainable system architecture. The core business rules are kept separate from, and independent of, those components that are either optional or that can be implemented in many different forms (Figure 17.5).",-1)),e[22]||(e[22]=t("blockquote",null,[t("p",null,"事实上，软件开发技术发展的历史就是一个如何想方设法方便地增加插件，从而构建一个可扩展、可维护的系统架构的故事。系统的核心业务逻辑必须和其他组件隔离，保持独立，而这些其他组件要么是可以去掉的，要么是有多种实现的（见图 17.5）。")],-1)),s(o,{figure:"17-5"},{default:n(()=>[...e[4]||(e[4]=[a("Plugging in to the business rules",-1)])]),_:1}),e[23]||(e[23]=i("",11)),s(o,{figure:"17-6"},{default:n(()=>[...e[5]||(e[5]=[a("ReSharper depends on Visual Studio",-1)])]),_:1}),e[24]||(e[24]=i("",15))])}const v=r(c,[["render",p]]);export{k as __pageData,v as default};
