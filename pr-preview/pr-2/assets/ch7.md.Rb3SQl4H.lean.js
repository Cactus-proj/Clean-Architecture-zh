import{_ as r,I as i,c as p,o as h,aj as n,J as s,j as t,w as l,a as o,aO as u}from"./chunks/framework.BLu8HwH_.js";const T=JSON.parse('{"title":"Chap7. SRP: THE SINGLE RESPONSIBILITY PRINCIPLE SRP：单一职责原则","description":"","frontmatter":{},"headers":[],"relativePath":"ch7.md","filePath":"ch7.md","lastUpdated":1767288275000}'),c={name:"ch7.md"};function d(m,e,b,f,k,y){const a=i("Figures");return h(),p("div",null,[e[5]||(e[5]=n("",29)),s(a,{figure:"7-1"},{default:l(()=>[...e[0]||(e[0]=[o("The Employee class",-1)])]),_:1}),e[6]||(e[6]=n("",9)),s(a,{figure:"7-2"},{default:l(()=>[...e[1]||(e[1]=[o("Shared algorithm",-1)])]),_:1}),e[7]||(e[7]=n("",29)),s(a,{figure:"7-3"},{default:l(()=>[...e[2]||(e[2]=[o("The three classes do not know about each other",-1)])]),_:1}),e[8]||(e[8]=t("p",null,"The downside of this solution is that the developers now have three classes that they have to instantiate and track. A common solution to this dilemma is to use the Facade pattern (Figure 7.4).",-1)),e[9]||(e[9]=t("blockquote",null,[t("p",null,"这种解决方案的坏处在于：程序员现在需要在程序里处理三个类。另一种解决办法是使用 Facade 设计模式（见图 7.4）。")],-1)),s(a,{figure:"7-4"},{default:l(()=>[...e[3]||(e[3]=[o("The Facade pattern",-1)])]),_:1}),e[10]||(e[10]=t("p",null,"The EmployeeFacade contains very little code. It is responsible for instantiating and delegating to the classes with the functions.",-1)),e[11]||(e[11]=t("blockquote",null,[t("p",null,"这样一来，EmployeeFacade 类所需要的代码量就很少了，它仅仅包含了初始化和调用三个具体实现类的函数。")],-1)),e[12]||(e[12]=t("p",null,"Some developers prefer to keep the most important business rules closer to the data. This can be done by keeping the most important method in the original Employee class and then using that class as a Facade for the lesser functions (Figure 7.5).",-1)),e[13]||(e[13]=t("blockquote",null,[t("p",null,"当然，也有些程序员更倾向于把最重要的业务逻辑与数据放在一起，那么我们也可以选择将最重要的函数保留在 Employee 类中，同时用这个类来调用其他没那么重要的函数（见图 7.5）。")],-1)),s(a,{figure:"7-5"},{default:l(()=>[...e[4]||(e[4]=[o("The most important method is kept in the original Employee class and used as a Facade for the lesser functions",-1)])]),_:1}),e[14]||(e[14]=t("p",null,"You might object to these solutions on the basis that every class would contain just one function. This is hardly the case. The number of functions required to calculate pay, generate a report, or save the data is likely to be large in each case. Each of those classes would have many private methods in them.",-1)),e[15]||(e[15]=t("blockquote",null,[t("p",null,"读者也许会反对上面这些解决方案，因为看上去这里的每个类中都只有一个函数。事实上并非如此，因为无论是计算工资、生成报表还是保存数据都是一个很复杂的过程，每个类都可能包含了许多私有函数。")],-1)),e[16]||(e[16]=t("p",null,"Each of the classes that contain such a family of methods is a scope. Outside of that scope, no one knows that the private members of the family exist.",-1)),e[17]||(e[17]=t("blockquote",null,[t("p",null,"总而言之，上面的每一个类都分别容纳了一组作用于相同作用域的函数，而在该作用域之外，它们各自的私有函数是互相不可见的。")],-1)),e[18]||(e[18]=t("h2",{id:"conclusion-本章小结",tabindex:"-1"},[o("CONCLUSION 本章小结 "),t("a",{class:"header-anchor",href:"#conclusion-本章小结","aria-label":"Permalink to “CONCLUSION 本章小结”"},"​")],-1)),e[19]||(e[19]=t("p",null,"The Single Responsibility Principle is about functions and classes—but it reappears in a different form at two more levels. At the level of components, it becomes the Common Closure Principle. At the architectural level, it becomes the Axis of Change responsible for the creation of Architectural Boundaries. We’ll be studying all of these ideas in the chapters to come.",-1)),e[20]||(e[20]=t("blockquote",null,[t("p",null,"单一职责原则主要讨论的是函数和类之间的关系——但是它在两个讨论层面上会以不同的形式出现。在组件层面，我们可以将其称为共同闭包原则（Common Closure Principle)，在软件架构层面，它则是用于奠定架构边界的变更轴心（Axis of Change）。我们在接下来的章节中会深入学习这些原则。")],-1))])}const q=r(c,[["render",d]]);export{T as __pageData,q as default};
