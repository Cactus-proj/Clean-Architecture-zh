<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chap9. LSP: THE LISKOV SUBSTITUTION PRINCIPLE LSP：里氏替换原则 | 《架构整洁之道》中文版</title>
    <meta name="description" content="架构整洁之道 罗伯特·C·马丁; Clean Code: A Handbook of Agile Software Craftsmanship 中文翻译; 代碼整潔之道 馬丁 (Robert C. Martin)">
    <meta name="generator" content="VitePress v2.0.0-alpha.15">
    <link rel="preload stylesheet" href="/Clean-Architecture-zh/pr-preview/pr-2/assets/style.C9M6RTIC.css" as="style">
    <link rel="preload stylesheet" href="/Clean-Architecture-zh/pr-preview/pr-2/vp-icons.css" as="style">
    
    <script type="module" src="/Clean-Architecture-zh/pr-preview/pr-2/assets/app.CXV5imkc.js"></script>
    <link rel="preload" href="/Clean-Architecture-zh/pr-preview/pr-2/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Clean-Architecture-zh/pr-preview/pr-2/assets/chunks/theme.C4WDDSQh.js">
    <link rel="modulepreload" href="/Clean-Architecture-zh/pr-preview/pr-2/assets/chunks/framework.BLu8HwH_.js">
    <link rel="modulepreload" href="/Clean-Architecture-zh/pr-preview/pr-2/assets/ch9.md.DrurpUBP.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1df9f90f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-331ec75c></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-331ec75c>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1df9f90f data-v-da52a441><div class="VPNavBar" data-v-da52a441 data-v-70946a35><div class="wrapper" data-v-70946a35><div class="container" data-v-70946a35><div class="title" data-v-70946a35><div class="VPNavBarTitle has-sidebar" data-v-70946a35 data-v-1e38c6bc><a class="title" href="/Clean-Architecture-zh/pr-preview/pr-2/" data-v-1e38c6bc><!--[--><!--]--><!----><span data-v-1e38c6bc>《架构整洁之道》中文版</span><!--[--><!--]--></a></div></div><div class="content" data-v-70946a35><div class="content-body" data-v-70946a35><!--[--><!--]--><div class="VPNavBarSearch search" data-v-70946a35><!--[--><!----><div id="local-search"><button type="button" aria-label="Search" aria-keyshortcuts="/ control+k meta+k" class="DocSearch DocSearch-Button"><span class="DocSearch-Button-Container"><span class="vpi-search DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key"></kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-70946a35 data-v-39714824><span id="main-nav-aria-label" class="visually-hidden" data-v-39714824> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Clean-Architecture-zh/pr-preview/pr-2/" tabindex="0" data-v-39714824 data-v-52a1d768><!--[--><span data-v-52a1d768>主页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Clean-Architecture-zh/pr-preview/pr-2/ch1.html" tabindex="0" data-v-39714824 data-v-52a1d768><!--[--><span data-v-52a1d768>章节正文</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-70946a35 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-70946a35 data-v-0394ad82 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Cactus-proj/Clean-Architecture-zh" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-70946a35 data-v-bf2fac68 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-42cb505d><span class="vpi-more-horizontal icon" data-v-42cb505d></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><!----><!--[--><!--[--><!----><div class="group" data-v-bf2fac68><div class="item appearance" data-v-bf2fac68><p class="label" data-v-bf2fac68>Appearance</p><div class="appearance-action" data-v-bf2fac68><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bf2fac68 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bf2fac68><div class="item social-links" data-v-bf2fac68><div class="VPSocialLinks social-links-list" data-v-bf2fac68 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Cactus-proj/Clean-Architecture-zh" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-70946a35 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-70946a35><div class="divider-line" data-v-70946a35></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-1df9f90f data-v-db738f89><div class="container" data-v-db738f89><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-db738f89><span class="vpi-align-left menu-icon" data-v-db738f89></span><span class="menu-text" data-v-db738f89>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-db738f89 data-v-0bf0e06f><button data-v-0bf0e06f>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-1df9f90f data-v-af661f50><div class="curtain" data-v-af661f50></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-af661f50><span class="visually-hidden" id="sidebar-aria-label" data-v-af661f50> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0 has-active" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>目录</h2><!----></div><div class="items" data-v-d81de50c><!--[--><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/part1.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第一部分 概述</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch1.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 1 章 设计与架构究竟是什么</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch2.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 2 章 两个价值维度</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/part2.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第二部分 从基础构件开始：编程范式</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch3.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 3 章 编程范式总览</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch4.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 4 章 结构化编程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch5.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 5 章 面向对象编程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch6.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 6 章 函数式编程</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link has-active" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/part3.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第三部分 设计原则</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch7.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 7 章 SRP：单一职责原则</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch8.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 8 章 OCP：开闭原则</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch9.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 9 章 LSP：里氏替换原则</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch10.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 10 章 ISP：接口隔离原则</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch11.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 11 章 DIP：依赖反转原则</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/part4.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第四部分 组件构建原则</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch12.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 12 章 组件</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch13.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 13 章 组件聚合</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch14.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 14 章 组件耦合</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/part5.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第五部分 软件架构</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch15.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 15 章 什么是软件架构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch16.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 16 章 独立性</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch17.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 17 章 划分边界</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch18.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 18 章 边界剖析</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch19.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 19 章 策略与层次</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch20.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 20 章 业务逻辑</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch21.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 21 章 尖叫的软件架构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch22.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 22 章 整洁架构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch23.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 23 章 展示器和谦卑对象</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch24.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 24 章 不完全边界</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch25.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 25 章 层次与边界</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch26.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 26 章 Main 组件</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch27.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 27 章 服务：宏观和微观</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch28.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 28 章 测试边界</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch29.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 29 章 整洁的嵌入式架构</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/part6.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第六部分 实现细节</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch30.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 30 章 数据库只是实现细节</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch31.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 31 章 Web 是实现细节</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch32.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 32 章 应用程序框架是实现细节</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch33.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 33 章 案例分析：视频销售网站</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-2/ch34.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 34 章 拾遗</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-1df9f90f data-v-c87f25bf><div class="VPDoc has-sidebar has-aside" data-v-c87f25bf data-v-7011f0d8><!--[--><!--]--><div class="container" data-v-7011f0d8><div class="aside" data-v-7011f0d8><div class="aside-curtain" data-v-7011f0d8></div><div class="aside-container" data-v-7011f0d8><div class="aside-content" data-v-7011f0d8><div class="VPDocAside" data-v-7011f0d8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-60d5052e><div class="content" data-v-60d5052e><div class="outline-marker" data-v-60d5052e></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-60d5052e>On this page</div><ul class="VPDocOutlineItem root" data-v-60d5052e data-v-1ce71065><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7011f0d8><div class="content-container" data-v-7011f0d8><!--[--><!--]--><main class="main" data-v-7011f0d8><div style="position:relative;" class="vp-doc _Clean-Architecture-zh_pr-preview_pr-2_ch9" data-v-7011f0d8><div><h1 id="chap9-lsp-the-liskov-substitution-principle-lsp-里氏替换原则" tabindex="-1">Chap9. LSP: THE LISKOV SUBSTITUTION PRINCIPLE LSP：里氏替换原则 <a class="header-anchor" href="#chap9-lsp-the-liskov-substitution-principle-lsp-里氏替换原则" aria-label="Permalink to “Chap9. LSP: THE LISKOV SUBSTITUTION PRINCIPLE LSP：里氏替换原则”">​</a></h1><p><img src="/Clean-Architecture-zh/pr-preview/pr-2/assets/CH-UN09.BO7P9iCg.jpg" alt=""></p><p>In 1988, Barbara Liskov wrote the following as a way of defining subtypes.</p><blockquote><p>1988 年，Barbara Liskov 在描述如何定义子类型时写下了这样一段话：</p></blockquote><p>What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.1</p><blockquote><p>这里需要的是一种可替换性：如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型。</p></blockquote><p>To understand this idea, which is known as the Liskov Substitution Principle (LSP), let’s look at some examples.</p><blockquote><p>为了让读者理解这段话中所体现的设计理念，也就是里氏替换原则（LSP），我们可以来看几个例子。</p></blockquote><h2 id="guiding-the-use-of-inheritance-继承的使用指导" tabindex="-1">GUIDING THE USE OF INHERITANCE 继承的使用指导 <a class="header-anchor" href="#guiding-the-use-of-inheritance-继承的使用指导" aria-label="Permalink to “GUIDING THE USE OF INHERITANCE 继承的使用指导”">​</a></h2><p>Imagine that we have a class named License, as shown in Figure 9.1. This class has a method named calcFee(), which is called by the Billing application. There are two “subtypes” of License: PersonalLicense and BusinessLicense. They use different algorithms to calculate the license fee.</p><blockquote><p>假设我们有一个 License 类，其结构如图 9.1 所示。该类中有一个名为 calcFee() 的方法，该方法将由 Billing 应用程序来调用。而 License 类有两个“子类型”：PersonalLicense 与 BusinessLicense，这两个类会用不同的算法来计算授权费用。</p></blockquote><div class="figure" data-v-0d18887f><div class="fg" data-v-0d18887f><div class="fgimg" data-v-0d18887f><img src="./figures/ch9/fg9-1.jpg" data-v-0d18887f></div></div><div class="fgtitle" data-v-0d18887f><p data-v-0d18887f> 图 9-1： <!--[-->License, and its derivatives, conform to LSP<!--]--></p></div></div><p>This design conforms to the LSP because the behavior of the Billing application does not depend, in any way, on which of the two subtypes it uses. Both of the subtypes are substitutable for the License type.</p><blockquote><p>上述设计是符合 LSP 原则的，因为 Billing 应用程序的行为并不依赖于其使用的任何一个衍生类。也就是说，这两个衍生类的对象都是可以用来替换 License 类对象的。</p></blockquote><h2 id="the-square-rectangle-problem-正方形-长方形问题" tabindex="-1">THE SQUARE/RECTANGLE PROBLEM 正方形/长方形问题 <a class="header-anchor" href="#the-square-rectangle-problem-正方形-长方形问题" aria-label="Permalink to “THE SQUARE/RECTANGLE PROBLEM 正方形/长方形问题”">​</a></h2><p>The canonical example of a violation of the LSP is the famed (or infamous, depending on your perspective) square/rectangle problem (Figure 9.2).</p><blockquote><p>正方形/长方形问题是个著名（或者说臭名远扬）的违反 LSP 的设计案例（这个问题的结构如图 9.2 所示）。</p></blockquote><div class="figure" data-v-0d18887f><div class="fg" data-v-0d18887f><div class="fgimg" data-v-0d18887f><img src="./figures/ch9/fg9-2.jpg" data-v-0d18887f></div></div><div class="fgtitle" data-v-0d18887f><p data-v-0d18887f> 图 9-2： <!--[-->The infamous square/rectangle problem<!--]--></p></div></div><p>In this example, Square is not a proper subtype of Rectangle because the height and width of the Rectangle are independently mutable; in contrast, the height and width of the Square must change together. Since the User believes it is communicating with a Rectangle, it could easily get confused. The following code shows why:</p><blockquote><p>在这个案例中，Square 类并不是 Rectangle 类的子类型，因为 Rectangle 类的高和宽可以分别修改，而 Square 类的高和宽则必须一同修改。由于 User 类 始终认为自己在操作 Rectangle 类，因此会带来一些混淆。例如在下面的代码中：</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Rectangle r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> …</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">area</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>If the … code produced a Square, then the assertion would fail.</p><blockquote><p>很显然，如果上述代码在…处返回的是 Square 类，则最后的这个 assert 是不会成立的。</p></blockquote><p>The only way to defend against this kind of LSP violation is to add mechanisms to the User (such as an if statement) that detects whether the Rectangle is, in fact, a Square. Since the behavior of the User depends on the types it uses, those types are not substitutable.</p><blockquote><p>如果想要防范这种违反 LSP 的行为，唯一的办法就是在 user 类中增加用于区分 Rectangle 和 Square 的检测逻辑（例如增加 if 语句）。但这样一来，user 为的行为又将依赖于它所使用的类，这两个类就不能互相替换了。</p></blockquote><h2 id="lsp-and-architecture-lsp-与软件架构" tabindex="-1">LSP AND ARCHITECTURE LSP 与软件架构 <a class="header-anchor" href="#lsp-and-architecture-lsp-与软件架构" aria-label="Permalink to “LSP AND ARCHITECTURE LSP 与软件架构”">​</a></h2><p>In the early years of the object-oriented revolution, we thought of the LSP as a way to guide the use of inheritance, as shown in the previous sections. However, over the years the LSP has morphed into a broader principle of software design that pertains to interfaces and implementations.</p><blockquote><p>在面向对象这场编程革命兴起的早期，我们的普遍认知正如上文所说，认为 LSP 只不过是指导如何使用继承关系的一种方法，然而随着时间的推移，LSP 逐渐演变成了一种更广泛的、指导接口与其实现方式的设计原则。</p></blockquote><p>The interfaces in question can be of many forms. We might have a Java-style interface, implemented by several classes. Or we might have several Ruby classes that share the same method signatures. Or we might have a set of services that all respond to the same REST interface.</p><blockquote><p>这里提到的接口可以有多种形式——可以是 Java 风格的接口，具有多个实现类；也可以像 Ruby 一样，几个类共用一样的方法签名，甚至可以是几个服务响应同一个 REST 接口。</p></blockquote><p>In all of these situations, and more, the LSP is applicable because there are users who depend on well-defined interfaces, and on the substitutability of the implementations of those interfaces.</p><blockquote><p>LSP 适用于上述所有的应用场景，因为这些场景中的用户都依赖于一种接口，并且都期待实现该接口的类之间能具有可替换性。</p></blockquote><p>The best way to understand the LSP from an architectural viewpoint is to look at what happens to the architecture of a system when the principle is violated.</p><blockquote><p>想要从软件架构的角度来理解 LSP 的意义，最好的办法还是来看几个反面案例。</p></blockquote><h2 id="example-lsp-violation-违反-lsp-的案例" tabindex="-1">EXAMPLE LSP VIOLATION 违反 LSP 的案例 <a class="header-anchor" href="#example-lsp-violation-违反-lsp-的案例" aria-label="Permalink to “EXAMPLE LSP VIOLATION 违反 LSP 的案例”">​</a></h2><p>Assume that we are building an aggregator for many taxi dispatch services. Customers use our website to find the most appropriate taxi to use, regardless of taxi company. Once the customer makes a decision, our system dispatches the chosen taxi by using a restful service.</p><blockquote><p>假设我们现在正在构建一个提供出租车调度服务的系统。在该系统中，用户可以通过访问我们的网站，从多个出租车公司内寻找最适合自己的出租车。当用户选定车子时，该系统会通过调用 restful 服务接口来调度这辆车。</p></blockquote><p>Now assume that the URI for the restful dispatch service is part of the information contained in the driver database. Once our system has chosen a driver appropriate for the customer, it gets that URI from the driver record and then uses it to dispatch the driver.</p><blockquote><p>接下来，我们再假设该 restful 调度服务接口的 URI 被存储在司机数据库中。一旦该系统选中了最合适的出租车司机，它就会从司机数据库的记录中读取相应的 URI 信息，并通过调用这个 URI 来调度汽车。</p></blockquote><p>Suppose Driver Bob has a dispatch URI that looks like this:</p><blockquote><p>也就是说，如果司机 Bob 的记录中包含如下调度 URI：</p></blockquote><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>purplecab.com/driver/Bob</span></span></code></pre></div><p>Our system will append the dispatch information onto this URI and send it with a PUT, as follows:</p><blockquote><p>那么，我们的系统就会将调度信息附加在这个 URI 上，并发送这样一个 PUT 请求：</p></blockquote><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>purplecab.com/driver/Bob</span></span>
<span class="line"><span>       /pickupAddress/24 Maple St.</span></span>
<span class="line"><span>       /pickupTime/153</span></span>
<span class="line"><span>       /destination/ORD</span></span></code></pre></div><p>Clearly, this means that all the dispatch services, for all the different companies, must conform to the same REST interface. They must treat the pickupAddress, pickupTime, and destination fields identically.</p><blockquote><p>很显然，这意味着所存参与该调度服务的公司都必须遵守同样的 REST 接口，它们必须用同样的方式处理 pickupAddress、pickupTime 和 destination 字段。</p></blockquote><p>Now suppose the Acme taxi company hired some programmers who didn’t read the spec very carefully. They abbreviated the destination field to just dest. Acme is the largest taxi company in our area, and Acme’s CEO’s ex-wife is our CEO’s new wife, and … Well, you get the picture. What would happen to the architecture of our system?</p><blockquote><p>接下来，我们再假设 Acme 出租车公司现在招聘的程序员由于没有仔细阅读上述接口定义，结果将 destination 字段缩写成了 dest。而 Acme 又是本地最大的出租车公司，另外，Acme CEO 的前妻不巧还是我们 CEO 的新欢……你懂的！这这会对系统的架构造成什么影响呢？</p></blockquote><p>Obviously, we would need to add a special case. The dispatch request for any Acme driver would have to be constructed using a different set of rules from all the other drivers.</p><blockquote><p>显然，我们需要为系统增加一类特殊用例，以应对 Acme 司机的调度请求。这必须要用另外一套规则来构建。</p></blockquote><p>The simplest way to accomplish this goal would be to add an if statement to the module that constructed the dispatch command:</p><blockquote><p>最简单的做法当然是增加一条 if 语句：</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (driver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDispatchUri</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startsWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;acme.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))…</span></span></code></pre></div><p>But, of course, no architect worth his or her salt would allow such a construction to exist in the system. Putting the word “acme” into the code itself creates an opportunity for all kinds of horrible and mysterious errors, not to mention security breaches.</p><blockquote><p>然而很明显，任何一个称职的软件架构师都不会允许这样一条语句出现在自己的系统中。因为直接将“acme”这样的字串写入代码会留下各种各样神奇又可怕的错误隐患，甚至会导致安全问题。</p></blockquote><p>For example, what if Acme became even more successful and bought the Purple Taxi company. What if the merged company maintained the separate brands and the separate websites, but unified all of the original companies’ systems? Would we have to add another if statement for “purple”?</p><blockquote><p>例如，Acme 也许会变得更加成功，最终收购了 Purple 出租车公司。然后，它们在保留了各自名字的同时却统一了彼此的计算机系统。在这种情况下，系统中难道还要再增加一条“purple”的特例吗？</p></blockquote><p>Our architect would have to insulate the system from bugs like this by creating some kind of dispatch command creation module that was driven by a configuration database keyed by the dispatch URI. The configuration data might look something like this:</p><blockquote><p>软件架构师应该创建一个调度请求创建组件，并让该组件使用一个配置数据库来保存 URI 组装格式，这样的方式可以保护系统不受外界因素变化的影响。例如其配置信息可以如下：</p></blockquote><table tabindex="0"><thead><tr><th>URI</th><th>Dispatch Format</th></tr></thead><tbody><tr><td>Acme.com</td><td>/pickupAddress/%s/pickupTime/%s/dest/%s</td></tr><tr><td><code>*.*</code></td><td>/pickupAddress/%s/pickupTime/%s/destination/%s</td></tr></tbody></table><p>And so our architect has had to add a significant and complex mechanism to deal with the fact that the interfaces of the restful services are not all substitutable.</p><blockquote><p>但这样一来，软件架构师就需要通过增加一个复杂的组件来应对并不完全能实现互相替换的 restful 服务接口。</p></blockquote><h2 id="conclusion-本章小结" tabindex="-1">CONCLUSION 本章小结 <a class="header-anchor" href="#conclusion-本章小结" aria-label="Permalink to “CONCLUSION 本章小结”">​</a></h2><p>The LSP can, and should, be extended to the level of architecture. A simple violation of substitutability, can cause a system’s architecture to be polluted with a significant amount of extra mechanisms.</p><blockquote><p>LSP 可以且应该被应用于软件架构层面，因为一旦违背了可替换也该系统架构就不得不为此增添大量复杂的应对机制。</p></blockquote></div></div></main><footer class="VPDocFooter" data-v-7011f0d8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><div class="edit-link" data-v-e257564d><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/Cactus-proj/Clean-Architecture-zh/edit/main/docs/ch9.md" target="_blank" rel="noreferrer" data-v-e257564d><!--[--><span class="vpi-square-pen edit-link-icon" data-v-e257564d></span> Edit this page<!--]--></a></div><div class="last-updated" data-v-e257564d><p class="VPLastUpdated" data-v-e257564d data-v-3c637f39>Last updated: <time datetime="2026-01-01T17:24:35.000Z" data-v-3c637f39></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/Clean-Architecture-zh/pr-preview/pr-2/ch8.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>第 8 章 OCP：开闭原则</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/Clean-Architecture-zh/pr-preview/pr-2/ch10.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>第 10 章 ISP：接口隔离原则</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"afterword.md\":\"F44S-Z0J\",\"ch1.md\":\"Frynhel9\",\"ch10.md\":\"D4Y-DEmR\",\"ch11.md\":\"Cc9k5nPn\",\"ch12.md\":\"Dv8vExJu\",\"ch13.md\":\"BDUNrOQZ\",\"ch14.md\":\"DBnZTGCc\",\"ch15.md\":\"TQQU_Nld\",\"ch16.md\":\"BlDIb_mu\",\"ch17.md\":\"CiI4_JOw\",\"ch18.md\":\"JsWPznW1\",\"ch19.md\":\"BBd1Bx-Z\",\"ch2.md\":\"CpqRYIVI\",\"ch20.md\":\"CdRYZukt\",\"ch21.md\":\"CJ0rKzO8\",\"ch22.md\":\"BJh0sBZW\",\"ch23.md\":\"CO8Xu1qe\",\"ch24.md\":\"CCyEmWXv\",\"ch25.md\":\"Cre9mSvk\",\"ch26.md\":\"wDx008me\",\"ch27.md\":\"Dk1gDUt5\",\"ch28.md\":\"5mvOJPeL\",\"ch29.md\":\"Dz9umriW\",\"ch3.md\":\"D6eZSA_z\",\"ch30.md\":\"5aelI6Ve\",\"ch31.md\":\"67J-JWYw\",\"ch32.md\":\"Dh5nLX8h\",\"ch33.md\":\"B_ZYV-po\",\"ch34.md\":\"BuJQagDL\",\"ch4.md\":\"DrtaYxTE\",\"ch5.md\":\"BjBM_4LC\",\"ch6.md\":\"TqeXJv3R\",\"ch7.md\":\"Rb3SQl4H\",\"ch8.md\":\"m35RRXdB\",\"ch9.md\":\"DrurpUBP\",\"index.md\":\"BL18oXQQ\",\"part1.md\":\"DzXay7GS\",\"part2.md\":\"D90ZTLCA\",\"part3.md\":\"CrI1bSR0\",\"part4.md\":\"Wlni58f4\",\"part5.md\":\"-8cFN5nh\",\"part6.md\":\"DC5YuLSY\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"《架构整洁之道》中文版\",\"description\":\"架构整洁之道 罗伯特·C·马丁; Clean Code: A Handbook of Agile Software Craftsmanship 中文翻译; 代碼整潔之道 馬丁 (Robert C. Martin)\",\"base\":\"/Clean-Architecture-zh/pr-preview/pr-2/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"主页\",\"link\":\"/\"},{\"text\":\"章节正文\",\"link\":\"/ch1\"}],\"sidebar\":[{\"text\":\"目录\",\"items\":[{\"text\":\"第一部分 概述\",\"link\":\"/part1\",\"items\":[{\"text\":\"第 1 章 设计与架构究竟是什么\",\"link\":\"/ch1\"},{\"text\":\"第 2 章 两个价值维度\",\"link\":\"/ch2\"}]},{\"text\":\"第二部分 从基础构件开始：编程范式\",\"link\":\"/part2\",\"items\":[{\"text\":\"第 3 章 编程范式总览\",\"link\":\"/ch3\"},{\"text\":\"第 4 章 结构化编程\",\"link\":\"/ch4\"},{\"text\":\"第 5 章 面向对象编程\",\"link\":\"/ch5\"},{\"text\":\"第 6 章 函数式编程\",\"link\":\"/ch6\"}]},{\"text\":\"第三部分 设计原则\",\"link\":\"/part3\",\"items\":[{\"text\":\"第 7 章 SRP：单一职责原则\",\"link\":\"/ch7\"},{\"text\":\"第 8 章 OCP：开闭原则\",\"link\":\"/ch8\"},{\"text\":\"第 9 章 LSP：里氏替换原则\",\"link\":\"/ch9\"},{\"text\":\"第 10 章 ISP：接口隔离原则\",\"link\":\"/ch10\"},{\"text\":\"第 11 章 DIP：依赖反转原则\",\"link\":\"/ch11\"}]},{\"text\":\"第四部分 组件构建原则\",\"link\":\"/part4\",\"items\":[{\"text\":\"第 12 章 组件\",\"link\":\"/ch12\"},{\"text\":\"第 13 章 组件聚合\",\"link\":\"/ch13\"},{\"text\":\"第 14 章 组件耦合\",\"link\":\"/ch14\"}]},{\"text\":\"第五部分 软件架构\",\"link\":\"/part5\",\"items\":[{\"text\":\"第 15 章 什么是软件架构\",\"link\":\"/ch15\"},{\"text\":\"第 16 章 独立性\",\"link\":\"/ch16\"},{\"text\":\"第 17 章 划分边界\",\"link\":\"/ch17\"},{\"text\":\"第 18 章 边界剖析\",\"link\":\"/ch18\"},{\"text\":\"第 19 章 策略与层次\",\"link\":\"/ch19\"},{\"text\":\"第 20 章 业务逻辑\",\"link\":\"/ch20\"},{\"text\":\"第 21 章 尖叫的软件架构\",\"link\":\"/ch21\"},{\"text\":\"第 22 章 整洁架构\",\"link\":\"/ch22\"},{\"text\":\"第 23 章 展示器和谦卑对象\",\"link\":\"/ch23\"},{\"text\":\"第 24 章 不完全边界\",\"link\":\"/ch24\"},{\"text\":\"第 25 章 层次与边界\",\"link\":\"/ch25\"},{\"text\":\"第 26 章 Main 组件\",\"link\":\"/ch26\"},{\"text\":\"第 27 章 服务：宏观和微观\",\"link\":\"/ch27\"},{\"text\":\"第 28 章 测试边界\",\"link\":\"/ch28\"},{\"text\":\"第 29 章 整洁的嵌入式架构\",\"link\":\"/ch29\"}]},{\"text\":\"第六部分 实现细节\",\"link\":\"/part6\",\"items\":[{\"text\":\"第 30 章 数据库只是实现细节\",\"link\":\"/ch30\"},{\"text\":\"第 31 章 Web 是实现细节\",\"link\":\"/ch31\"},{\"text\":\"第 32 章 应用程序框架是实现细节\",\"link\":\"/ch32\"},{\"text\":\"第 33 章 案例分析：视频销售网站\",\"link\":\"/ch33\"},{\"text\":\"第 34 章 拾遗\",\"link\":\"/ch34\"}]}]}],\"search\":{\"provider\":\"local\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Cactus-proj/Clean-Architecture-zh\"}],\"editLink\":{\"pattern\":\"https://github.com/Cactus-proj/Clean-Architecture-zh/edit/main/docs/:path\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>