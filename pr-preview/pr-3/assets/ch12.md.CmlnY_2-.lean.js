import{_ as l,I as i,c as p,o as d,aj as o,J as n,j as a,w as s,a as r,an as c}from"./chunks/framework.BHja0GR4.js";const w=JSON.parse('{"title":"Chap12. COMPONENTS 组件","description":"","frontmatter":{},"headers":[],"relativePath":"ch12.md","filePath":"ch12.md","lastUpdated":1767288281000}'),h={name:"ch12.md"};function u(m,e,b,g,f,y){const t=i("Figures");return d(),p("div",null,[e[2]||(e[2]=o("",24)),n(t,{figure:"12-1"},{default:s(()=>[...e[0]||(e[0]=[r("Early memory layout",-1)])]),_:1}),e[3]||(e[3]=a("p",null,"This worked fine so long as the application could fit between addresses 00008 and 17778. But soon applications grew to be larger than the space allotted for them. At that point, programmers had to split their applications into two address segments, jumping around the function library (Figure 12.2).",-1)),e[4]||(e[4]=a("blockquote",null,[a("p",null,"当然，只要应用程序的代码能够完全存放在地址 0000〜1777（八进制）内，这种组织方式就没有任何问题。但是，应用程序代码的大小很快就会超出这个范围。为了解决这个问题，程序员们必须将应用程序代码切分成两个不同的地址段，以跳过库函数存放的内存范围（具体如图 12.2 所示）。")],-1)),n(t,{figure:"12-2"},{default:s(()=>[...e[1]||(e[1]=[r("Splitting the application into two address segments",-1)])]),_:1}),e[5]||(e[5]=o("",41))])}const T=l(h,[["render",u]]);export{w as __pageData,T as default};
