<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chap3. PARADIGM OVERVIEW 编程范式总览 | 《架构整洁之道》中文版</title>
    <meta name="description" content="架构整洁之道 罗伯特·C·马丁; Clean Code: A Handbook of Agile Software Craftsmanship 中文翻译; 代碼整潔之道 馬丁 (Robert C. Martin)">
    <meta name="generator" content="VitePress v2.0.0-alpha.16">
    <link rel="preload stylesheet" href="/Clean-Architecture-zh/pr-preview/pr-3/assets/style.Cik10Pcs.css" as="style">
    <link rel="preload stylesheet" href="/Clean-Architecture-zh/pr-preview/pr-3/vp-icons.css" as="style">
    
    <script type="module" src="/Clean-Architecture-zh/pr-preview/pr-3/assets/app.BWIg5hQO.js"></script>
    <link rel="preload" href="/Clean-Architecture-zh/pr-preview/pr-3/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Clean-Architecture-zh/pr-preview/pr-3/assets/chunks/theme.B1g_yIho.js">
    <link rel="modulepreload" href="/Clean-Architecture-zh/pr-preview/pr-3/assets/chunks/framework.BCtlrW0c.js">
    <link rel="modulepreload" href="/Clean-Architecture-zh/pr-preview/pr-3/assets/ch3.md.BTihuau6.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1df9f90f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-331ec75c></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-331ec75c>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1df9f90f data-v-9f75dce3><div class="VPNavBar has-sidebar top" data-v-9f75dce3 data-v-9ca1369d><div class="wrapper" data-v-9ca1369d><div class="container" data-v-9ca1369d><div class="title" data-v-9ca1369d><div class="VPNavBarTitle has-sidebar" data-v-9ca1369d data-v-1e38c6bc><a class="title" href="/Clean-Architecture-zh/pr-preview/pr-3/" data-v-1e38c6bc><!--[--><!--]--><!----><span data-v-1e38c6bc>《架构整洁之道》中文版</span><!--[--><!--]--></a></div></div><div class="content" data-v-9ca1369d><div class="content-body" data-v-9ca1369d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9ca1369d data-v-2fc7f2c6><!--[--><button type="button" class="VPNavBarSearchButton" aria-label="Search" aria-keyshortcuts="/ control+k meta+k" data-v-2fc7f2c6 data-v-baa3be99><span class="vpi-search" aria-hidden="true" data-v-baa3be99></span><span class="text" data-v-baa3be99>Search</span><span class="keys" aria-hidden="true" data-v-baa3be99><kbd class="key-cmd" data-v-baa3be99>⌘</kbd><kbd class="key-ctrl" data-v-baa3be99>Ctrl</kbd><kbd data-v-baa3be99>K</kbd></span></button><!----><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9ca1369d data-v-39714824><span id="main-nav-aria-label" class="visually-hidden" data-v-39714824> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Clean-Architecture-zh/pr-preview/pr-3/" tabindex="0" data-v-39714824 data-v-52a1d768><!--[--><span data-v-52a1d768>主页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Clean-Architecture-zh/pr-preview/pr-3/ch1.html" tabindex="0" data-v-39714824 data-v-52a1d768><!--[--><span data-v-52a1d768>章节正文</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9ca1369d data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9ca1369d data-v-0394ad82 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Cactus-proj/Clean-Architecture-zh" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9ca1369d data-v-bf2fac68 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-42cb505d><span class="vpi-more-horizontal icon" data-v-42cb505d></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><!----><!--[--><!--[--><!----><div class="group" data-v-bf2fac68><div class="item appearance" data-v-bf2fac68><p class="label" data-v-bf2fac68>Appearance</p><div class="appearance-action" data-v-bf2fac68><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bf2fac68 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bf2fac68><div class="item social-links" data-v-bf2fac68><div class="VPSocialLinks social-links-list" data-v-bf2fac68 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Cactus-proj/Clean-Architecture-zh" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9ca1369d data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-9ca1369d><div class="divider-line" data-v-9ca1369d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-1df9f90f data-v-db738f89><div class="container" data-v-db738f89><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-db738f89><span class="vpi-align-left menu-icon" data-v-db738f89></span><span class="menu-text" data-v-db738f89>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-db738f89 data-v-0bf0e06f><button data-v-0bf0e06f>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-1df9f90f data-v-af661f50><div class="curtain" data-v-af661f50></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-af661f50><span class="visually-hidden" id="sidebar-aria-label" data-v-af661f50> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0 has-active" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>目录</h2><!----></div><div class="items" data-v-d81de50c><!--[--><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/part1.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第一部分 概述</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch1.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 1 章 设计与架构究竟是什么</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch2.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 2 章 两个价值维度</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link has-active" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/part2.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第二部分 从基础构件开始：编程范式</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch3.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 3 章 编程范式总览</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch4.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 4 章 结构化编程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch5.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 5 章 面向对象编程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch6.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 6 章 函数式编程</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/part3.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第三部分 设计原则</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch7.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 7 章 SRP：单一职责原则</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch8.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 8 章 OCP：开闭原则</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch9.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 9 章 LSP：里氏替换原则</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch10.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 10 章 ISP：接口隔离原则</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch11.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 11 章 DIP：依赖反转原则</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/part4.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第四部分 组件构建原则</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch12.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 12 章 组件</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch13.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 13 章 组件聚合</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch14.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 14 章 组件耦合</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/part5.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第五部分 软件架构</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch15.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 15 章 什么是软件架构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch16.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 16 章 独立性</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch17.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 17 章 划分边界</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch18.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 18 章 边界剖析</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch19.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 19 章 策略与层次</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch20.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 20 章 业务逻辑</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch21.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 21 章 尖叫的软件架构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch22.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 22 章 整洁架构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch23.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 23 章 展示器和谦卑对象</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch24.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 24 章 不完全边界</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch25.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 25 章 层次与边界</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch26.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 26 章 Main 组件</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch27.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 27 章 服务：宏观和微观</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch28.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 28 章 测试边界</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch29.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 29 章 整洁的嵌入式架构</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/part6.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>第六部分 实现细节</h3><!--]--></a><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch30.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 30 章 数据库只是实现细节</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch31.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 31 章 Web 是实现细节</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch32.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 32 章 应用程序框架是实现细节</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch33.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 33 章 案例分析：视频销售网站</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/Clean-Architecture-zh/pr-preview/pr-3/ch34.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>第 34 章 拾遗</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-1df9f90f data-v-c87f25bf><div class="VPDoc has-sidebar has-aside" data-v-c87f25bf data-v-7011f0d8><!--[--><!--]--><div class="container" data-v-7011f0d8><div class="aside" data-v-7011f0d8><div class="aside-curtain" data-v-7011f0d8></div><div class="aside-container" data-v-7011f0d8><div class="aside-content" data-v-7011f0d8><div class="VPDocAside" data-v-7011f0d8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-60d5052e><div class="content" data-v-60d5052e><div class="outline-marker" data-v-60d5052e></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-60d5052e>On this page</div><ul class="VPDocOutlineItem root" data-v-60d5052e data-v-1ce71065><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7011f0d8><div class="content-container" data-v-7011f0d8><!--[--><!--]--><main class="main" data-v-7011f0d8><div style="position:relative;" class="vp-doc _Clean-Architecture-zh_pr-preview_pr-3_ch3" data-v-7011f0d8><div><h1 id="chap3-paradigm-overview-编程范式总览" tabindex="-1">Chap3. PARADIGM OVERVIEW 编程范式总览 <a class="header-anchor" href="#chap3-paradigm-overview-编程范式总览" aria-label="Permalink to “Chap3. PARADIGM OVERVIEW 编程范式总览”">​</a></h1><p><img src="/Clean-Architecture-zh/pr-preview/pr-3/assets/CH-UN03.C6NlNdU3.jpg" alt=""></p><p>The three paradigms included in this overview chapter are structured programming, object-orient programming, and functional programming.</p><blockquote><p>本章将讲述三个编程范式，它们分别是结构化编程（structured programming）、 面向对象编程（object-oriented programming）以及函数式编程（functional programming）。</p></blockquote><h2 id="structured-programming-结构化编程" tabindex="-1">STRUCTURED PROGRAMMING 结构化编程 <a class="header-anchor" href="#structured-programming-结构化编程" aria-label="Permalink to “STRUCTURED PROGRAMMING 结构化编程”">​</a></h2><p>The first paradigm to be adopted (but not the first to be invented) was structured programming, which was discovered by Edsger Wybe Dijkstra in 1968. Dijkstra showed that the use of unrestrained jumps (goto statements) is harmful to program structure. As we’ll see in the chapters that follow, he replaced those jumps with the more familiar if/then/else and do/while/until constructs.</p><blockquote><p>结构化编程是第一个普遍被采用的编程范式（但是却不是第一个被提出的），由 Edsger Wybe Dijkstra 于 1968 年最先提出。与此同时，Dijkstra 还论证了使用 goto 这样的无限制跳转语句将会损害程序的整体结构。接下来的章节我们还会说到，二是这位 Dijkstra 最先主张用我们现在熟知的 if/then/else 语句和 do/while/until 语句来代替跳转语句的。</p></blockquote><p>We can summarize the structured programming paradigm as follows:</p><blockquote><p>我们可以将结构化编程范式归结为一句话：</p></blockquote><p>Structured programming imposes discipline on direct transfer of control.</p><blockquote><p>结构化编程对程序控制权的直接转移进行了限制和规范。</p></blockquote><h2 id="object-oriented-programming-面向对象编程" tabindex="-1">OBJECT-ORIENTED PROGRAMMING 面向对象编程 <a class="header-anchor" href="#object-oriented-programming-面向对象编程" aria-label="Permalink to “OBJECT-ORIENTED PROGRAMMING 面向对象编程”">​</a></h2><p>The second paradigm to be adopted was actually discovered two years earlier, in 1966, by Ole Johan Dahl and Kristen Nygaard. These two programmers noticed that the function call stack frame in the ALGOL language could be moved to a heap, thereby allowing local variables declared by a function to exist long after the function returned. The function became a constructor for a class, the local variables became instance variables, and the nested functions became methods. This led inevitably to the discovery of polymorphism through the disciplined use of function pointers.</p><blockquote><p>说到编程领域中第二个被广泛采用的编程范式，当然就是面向对象编程了：事实上，这个编程范式的提出比结构化编程还早了两年，是在 1966 年由 Ole Johan Dahl 和 Kriste Nygaard 在论文中总结归纳出来的。这两个程序员注意到在 ALGOL 语言中. 函数调用堆栈（call stack frame）可以被挪到堆内存区域里，这样函数定义的本地变量就可以在函数返回之后继续存在。这个函数就成为了一个类（class）的构造函数，而它所定义的本地变量就是类的成员变量，构造函数定义的嵌套函数就成为了成员方法（method）。这样一来，我们就可以利用多态（polymorphism）来限制用户对函数指针的使用。</p></blockquote><p>We can summarize the object-oriented programming paradigm as follows:</p><blockquote><p>在这里，我们也可以用一句话来总结面向对象编程：</p></blockquote><p>Object-oriented programming imposes discipline on indirect transfer of control.</p><blockquote><p>面向对象编程对程序控制权的间接转移进行了限制和规范。</p></blockquote><h2 id="functional-programming-函数式编程" tabindex="-1">FUNCTIONAL PROGRAMMING 函数式编程 <a class="header-anchor" href="#functional-programming-函数式编程" aria-label="Permalink to “FUNCTIONAL PROGRAMMING 函数式编程”">​</a></h2><p>The third paradigm, which has only recently begun to be adopted, was the first to be invented. Indeed, its invention predates computer programming itself. Functional programming is the direct result of the work of Alonzo Church, who in 1936 invented l-calculus while pursuing the same mathematical problem that was motivating Alan Turing at the same time. His l-calculus is the foundation of the LISP language, invented in 1958 by John McCarthy. A foundational notion of l-calculus is immutability—that is, the notion that the values of symbols do not change. This effectively means that a functional language has no assignment statement. Most functional languages do, in fact, have some means to alter the value of a variable, but only under very strict discipline.</p><blockquote><p>尽管第三个编程范式是近些年才刚刚开始被采用的，但它其实是三个范式中最先被发明的。事实上，函数式编程概念是基于与阿兰·图灵同时代的数学家 Alonzo Church 在 1936 年发明的入演算的直接衍生物。1958 年 John Mccarthy 利用其作为基础发明了 LISP 语言。众所周知，λ 演算法的一个核心思想是不可变性——某个符号所对应的值是永远不变的，所以从理论上来说，函数式编程语言中应该是没有赋值语句的。大部分函数式编程语言只允许在非常严格的限制条件下，才可以更改某个变量的值。</p></blockquote><p>We can summarize the functional programming paradigm as follows:</p><blockquote><p>因此，我们在这里可以将函数式编程范式总结为下面这句话：</p></blockquote><p>Functional programming imposes discipline upon assignment.</p><blockquote><p>函数式编程对程序中的赋值进行了限制和规范。</p></blockquote><h2 id="food-for-thought-仅供思考" tabindex="-1">FOOD FOR THOUGHT 仅供思考 <a class="header-anchor" href="#food-for-thought-仅供思考" aria-label="Permalink to “FOOD FOR THOUGHT 仅供思考”">​</a></h2><p>Notice the pattern that I’ve quite deliberately set up in introducing these three programming paradigms: Each of the paradigms removes capabilities from the programmer. None of them adds new capabilities. Each imposes some kind of extra discipline that is negative in its intent. The paradigms tell us what not to do, more than they tell us what to do.</p><blockquote><p>如你所见，我在介绍三个编程范式的时候，有意采用了上面这种格式，目的是凸显每个编程范式的实际含义——它们都从某一方面限制和规范了程序员的能力。没有一个范式是增加新能力的。也就是说，每个编程范式的目的都是设置限制。这些范式主要是为了告诉我们不能做什么，而不是可以做什么。</p></blockquote><p>Another way to look at this issue is to recognize that each paradigm takes something away from us. The three paradigms together remove goto statements, function pointers, and assignment. Is there anything left to take away?</p><blockquote><p>另外，我们应该认识到，这三个编程范式分别限制了 goto 语句、函数指针和赋值语句的使用。那么除此之外，还有什么可以去除的吗？</p></blockquote><p>Probably not. Thus these three paradigms are likely to be the only three we will see—at least the only three that are negative. Further evidence that there are no more such paradigms is that they were all discovered within the ten years between 1958 and 1968. In the many decades that have followed, no new paradigms have been added.</p><blockquote><p>可能没有了。因此这三个编程范式可能是仅有的三个了——如果单论去除能力的编程范式的话。支撑这一结论的另外一个证据是，三个编程范式都是在 1958 年到 1968 年这 10 年间被提出来的，后续再也没有新的编程范式出现过。</p></blockquote><h2 id="conclusion-本章小结" tabindex="-1">CONCLUSION 本章小结 <a class="header-anchor" href="#conclusion-本章小结" aria-label="Permalink to “CONCLUSION 本章小结”">​</a></h2><p>What does this history lesson on paradigms have to do with architecture? Everything. We use polymorphism as the mechanism to cross architectural boundaries; we use functional programming to impose discipline on the location of and access to data; and we use structured programming as the algorithmic foundation of our modules.</p><blockquote><p>大家可能会问，这些编程范式的历史知识与软件架构有关系吗？当然有，而目关系相当密切。譬如说，多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是各模块的算法实现基础。</p></blockquote><p>Notice how well those three align with the three big concerns of architecture: function, separation of components, and data management.</p><blockquote><p>这和软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。</p></blockquote></div></div></main><footer class="VPDocFooter" data-v-7011f0d8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><div class="edit-link" data-v-e257564d><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/Cactus-proj/Clean-Architecture-zh/edit/main/docs/ch3.md" target="_blank" rel="noreferrer" data-v-e257564d><!--[--><span class="vpi-square-pen edit-link-icon" data-v-e257564d></span> Edit this page<!--]--></a></div><div class="last-updated" data-v-e257564d><p class="VPLastUpdated" data-v-e257564d data-v-3c637f39>Last updated: <time datetime="2026-02-10T11:53:40.000Z" data-v-3c637f39></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/Clean-Architecture-zh/pr-preview/pr-3/part2.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>第二部分 从基础构件开始：编程范式</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/Clean-Architecture-zh/pr-preview/pr-3/ch4.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>第 4 章 结构化编程</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"afterword.md\":\"BoLkflWk\",\"ch1.md\":\"dbXykrQJ\",\"ch10.md\":\"xIJGD-kC\",\"ch11.md\":\"DTF7Sq1R\",\"ch12.md\":\"Be2y3Dae\",\"ch13.md\":\"RJK4AUK8\",\"ch14.md\":\"DD0MDM12\",\"ch15.md\":\"CN17Sxo-\",\"ch16.md\":\"C2FdJa2l\",\"ch17.md\":\"BuiIPzq3\",\"ch18.md\":\"DUrD-5JN\",\"ch19.md\":\"tShyWt3k\",\"ch2.md\":\"Bt4RLE9a\",\"ch20.md\":\"BU50JQPj\",\"ch21.md\":\"DQjSgAmP\",\"ch22.md\":\"CR_xXtVE\",\"ch23.md\":\"CPqbB7Sb\",\"ch24.md\":\"C_SE-E8w\",\"ch25.md\":\"CjDXYFcm\",\"ch26.md\":\"4L5YNjbb\",\"ch27.md\":\"BIxQwQVL\",\"ch28.md\":\"D5PzOjbW\",\"ch29.md\":\"1fpQAXDc\",\"ch3.md\":\"BTihuau6\",\"ch30.md\":\"R9_T18ne\",\"ch31.md\":\"RBkf2gic\",\"ch32.md\":\"DlKtWe36\",\"ch33.md\":\"Bz_ZTXVB\",\"ch34.md\":\"DgNB6j7l\",\"ch4.md\":\"EfCsDjFg\",\"ch5.md\":\"BUy9Y5WM\",\"ch6.md\":\"E45GYMGP\",\"ch7.md\":\"D6iJTJo0\",\"ch8.md\":\"Bi1tGYpm\",\"ch9.md\":\"CptDOgxB\",\"index.md\":\"Bmls3LZi\",\"part1.md\":\"CdewEPaA\",\"part2.md\":\"BqyO1V3j\",\"part3.md\":\"D5sPsZwL\",\"part4.md\":\"B9s2zfOZ\",\"part5.md\":\"DIsc9yoQ\",\"part6.md\":\"BZmHQQif\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"《架构整洁之道》中文版\",\"description\":\"架构整洁之道 罗伯特·C·马丁; Clean Code: A Handbook of Agile Software Craftsmanship 中文翻译; 代碼整潔之道 馬丁 (Robert C. Martin)\",\"base\":\"/Clean-Architecture-zh/pr-preview/pr-3/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"主页\",\"link\":\"/\"},{\"text\":\"章节正文\",\"link\":\"/ch1\"}],\"sidebar\":[{\"text\":\"目录\",\"items\":[{\"text\":\"第一部分 概述\",\"link\":\"/part1\",\"items\":[{\"text\":\"第 1 章 设计与架构究竟是什么\",\"link\":\"/ch1\"},{\"text\":\"第 2 章 两个价值维度\",\"link\":\"/ch2\"}]},{\"text\":\"第二部分 从基础构件开始：编程范式\",\"link\":\"/part2\",\"items\":[{\"text\":\"第 3 章 编程范式总览\",\"link\":\"/ch3\"},{\"text\":\"第 4 章 结构化编程\",\"link\":\"/ch4\"},{\"text\":\"第 5 章 面向对象编程\",\"link\":\"/ch5\"},{\"text\":\"第 6 章 函数式编程\",\"link\":\"/ch6\"}]},{\"text\":\"第三部分 设计原则\",\"link\":\"/part3\",\"items\":[{\"text\":\"第 7 章 SRP：单一职责原则\",\"link\":\"/ch7\"},{\"text\":\"第 8 章 OCP：开闭原则\",\"link\":\"/ch8\"},{\"text\":\"第 9 章 LSP：里氏替换原则\",\"link\":\"/ch9\"},{\"text\":\"第 10 章 ISP：接口隔离原则\",\"link\":\"/ch10\"},{\"text\":\"第 11 章 DIP：依赖反转原则\",\"link\":\"/ch11\"}]},{\"text\":\"第四部分 组件构建原则\",\"link\":\"/part4\",\"items\":[{\"text\":\"第 12 章 组件\",\"link\":\"/ch12\"},{\"text\":\"第 13 章 组件聚合\",\"link\":\"/ch13\"},{\"text\":\"第 14 章 组件耦合\",\"link\":\"/ch14\"}]},{\"text\":\"第五部分 软件架构\",\"link\":\"/part5\",\"items\":[{\"text\":\"第 15 章 什么是软件架构\",\"link\":\"/ch15\"},{\"text\":\"第 16 章 独立性\",\"link\":\"/ch16\"},{\"text\":\"第 17 章 划分边界\",\"link\":\"/ch17\"},{\"text\":\"第 18 章 边界剖析\",\"link\":\"/ch18\"},{\"text\":\"第 19 章 策略与层次\",\"link\":\"/ch19\"},{\"text\":\"第 20 章 业务逻辑\",\"link\":\"/ch20\"},{\"text\":\"第 21 章 尖叫的软件架构\",\"link\":\"/ch21\"},{\"text\":\"第 22 章 整洁架构\",\"link\":\"/ch22\"},{\"text\":\"第 23 章 展示器和谦卑对象\",\"link\":\"/ch23\"},{\"text\":\"第 24 章 不完全边界\",\"link\":\"/ch24\"},{\"text\":\"第 25 章 层次与边界\",\"link\":\"/ch25\"},{\"text\":\"第 26 章 Main 组件\",\"link\":\"/ch26\"},{\"text\":\"第 27 章 服务：宏观和微观\",\"link\":\"/ch27\"},{\"text\":\"第 28 章 测试边界\",\"link\":\"/ch28\"},{\"text\":\"第 29 章 整洁的嵌入式架构\",\"link\":\"/ch29\"}]},{\"text\":\"第六部分 实现细节\",\"link\":\"/part6\",\"items\":[{\"text\":\"第 30 章 数据库只是实现细节\",\"link\":\"/ch30\"},{\"text\":\"第 31 章 Web 是实现细节\",\"link\":\"/ch31\"},{\"text\":\"第 32 章 应用程序框架是实现细节\",\"link\":\"/ch32\"},{\"text\":\"第 33 章 案例分析：视频销售网站\",\"link\":\"/ch33\"},{\"text\":\"第 34 章 拾遗\",\"link\":\"/ch34\"}]}]}],\"search\":{\"provider\":\"local\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Cactus-proj/Clean-Architecture-zh\"}],\"editLink\":{\"pattern\":\"https://github.com/Cactus-proj/Clean-Architecture-zh/edit/main/docs/:path\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>