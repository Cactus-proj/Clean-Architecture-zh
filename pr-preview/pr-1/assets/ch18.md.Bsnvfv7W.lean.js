import{_ as l,I as r,c,o as h,aj as n,J as s,j as o,w as i,a as t,as as p}from"./chunks/framework.BcNnd3qu.js";const v=JSON.parse('{"title":"Chap18. BOUNDARY ANATOMY 边界剖析","description":"","frontmatter":{},"headers":[],"relativePath":"ch18.md","filePath":"ch18.md","lastUpdated":1764586477000}'),d={name:"ch18.md"};function m(u,e,b,y,f,g){const a=r("Figures");return h(),c("div",null,[e[2]||(e[2]=n("",22)),s(a,{figure:"18-1"},{default:i(()=>[...e[0]||(e[0]=[t("Flow of control crosses the boundary from a lower level to a higher level",-1)])]),_:1}),e[3]||(e[3]=o("p",null,"When a high-level client needs to invoke a lower-level service, dynamic polymorphism is used to invert the dependency against the flow of control. The runtime dependency opposes the compile-time dependency.",-1)),e[4]||(e[4]=o("blockquote",null,[o("p",null,"但当高层组件中的客户端需要调用低层组件中的服务时，我们就需要运用动态形式的多态来反转依赖关系了。在这种情况下，系统在运行时的依赖关系与编译时的依赖关系就是相反的。")],-1)),e[5]||(e[5]=o("p",null,"In Figure 18.2, the flow of control crosses the boundary from left to right as before. The high-level Client calls the f() function of the lower-level ServiceImpl through the Service interface. Note, however, that all dependencies cross the boundary from right to left toward the higher-level component. Note, also, that the definition of the data structure is on the calling side of the boundary.",-1)),e[6]||(e[6]=o("blockquote",null,[o("p",null,[t("在图 18.2 中，控制流跨越边界的方向与之前是一样的，都是从左至右的。这里是高层组件 Client 通过 Service 接口调用了低层组件 Servicelmpl 上的函数 "),o("code",null,"f()"),t("。但请读者注意，图 18.2 中所有的依赖关系却都是从右向左跨越边界的，方向是由低层组件指向高层组件的。同时，我们也应该注意到，这一次数据结构的定义是位于调用方这一侧的。")])],-1)),s(a,{figure:"18-2"},{default:i(()=>[...e[1]||(e[1]=[t("Crossing the boundary against the flow of control",-1)])]),_:1}),e[7]||(e[7]=n("",43))])}const q=l(d,[["render",m]]);export{v as __pageData,q as default};
